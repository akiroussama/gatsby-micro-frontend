{"componentChunkName":"component---src-templates-docs-js","path":"/introduction","webpackCompilationHash":"cdc2f46a6c30e66c935d","result":{"data":{"site":{"siteMetadata":{"title":"Micro Frontends: C'est une nouvelle ère qui commence ","docsLocation":"https://github.com/hasura/gatsby-gitbook-boilerplate/tree/master/content"}},"mdx":{"fields":{"id":"513b0c49-fc45-5e2a-8399-e2179a3e7b5f","title":"Qu'est-ce que l'architecture micro frontend ?","slug":"/introduction"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Qu'est-ce que l'architecture micro frontend ?\",\n  \"metaTitle\": \"Qu'est-ce que l'architecture micro frontend\",\n  \"metaDescription\": \"Qu'est-ce que l'architecture micro frontend\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Les infrastructures Microservices sont le fruit d\\u2019un constat simple : les applications monolithes sont difficiles \\xE0 g\\xE9rer, maintenir ou moderniser. Il fallait donc trouver un moyen de r\\xE9duire la codebase en petit s\\xEElots qui seraient plus simples \\xE0 faire \\xE9voluer.\\nCette solution trouv\\xE9e pour la structure \\u201Cback\\u201D, il nous reste toujours la probl\\xE9matique du web front o\\xF9 nous avons une SPA qui est en fait un monolithe en soit. La gestion de modules, le lazy-loading, etc. nous permettent d\\u2019am\\xE9liorer la structure, mais la codebase reste commune. Il nous faut donc maintenant splitter cela et ainsi cr\\xE9er des micro-frontends.\\n\", mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://graphql-engine-cdn.hasura.io/learn-hasura/assets/graphql-react/graphql-on-http.png\",\n    \"alt\": \"GraphQL over HTTP\"\n  }))), mdx(\"h2\", null, \"TL; DR;\"), mdx(\"p\", null, \"Les architecture backend se sont orient\\xE9s vers les microservices afin de mieux d\\xE9couper les codebases en petites briques ind\\xE9pendantes et ainsi am\\xE9liorer la maintenabilit\\xE9.\\nL\\u2019architecture frontend suit ce trend afin \\xE9galement de mieux se structurer et permettre une meilleure r\\xE9utilisation de modules ind\\xE9pendants au sein d\\u2019applications.\\nDans ce but, plusieurs solutions sont possibles, mais un rapide comparatif nous montre qu\\u2019actuellement les plus efficaces autant au niveau technique qu\\u2019au niveau rendu utilisateur, sont l\\u2019utilisation des technologies WebComponents. Ceci, que ce soit directement avec la cr\\xE9ation de WebComponents ou via des Framework based components.\"), mdx(\"h2\", null, \"Du monolithe aux microservices\"), mdx(\"p\", null, \"On le sait tous, les applications \\xE0 l\\u2019ancienne se faisait au moyen de monolithe qui \\xE0 la base \\xE9tait une app (data-layer + logique + pr\\xE9sentation) pour un domaine pr\\xE9cis, puis au fur et \\xE0 mesure grandissait jusqu\\u2019\\xE0 devenir une codebase qui contient tout plein de choses (ex: SAP, SIRH \\u2026).\\nPour mieux d\\xE9couper ces codebases et faciliter la maintenance, le back s\\u2019est petit \\xE0 petit divis\\xE9 en structures ind\\xE9pendantes, jusqu\\u2019\\xE0 devenir des microservices. Le but de cet exemple microservice n\\u2019est pas d\\u2019expliquer cette transformation d\\xE9j\\xE0 connue, mais juste de montrer les similitudes avec ce que les technologies frontend tentent de faire et vers quoi elles veulent aller.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Step 1 : Le monolithe\\nTout est dans la m\\xEAme solution. On retrouve notre business logique dans la m\\xEAme codebase que le data access et les pages du UI frontend. Une modification d\\u2019une couche n\\xE9cessite un d\\xE9ploiement de toute la solution.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Step 2 : La s\\xE9paration Back-Front\\nAvec l\\u2019arriv\\xE9e des XHR (xml http requests), le frontend se s\\xE9pare et devient un \\xE9l\\xE9ment \\xE0 lui seul. La partie backend, elle, garde ses multiples couches.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Step 3 : Les Microservices\\nLe splitting en architecture microservice permet d\\u2019isoler les domaines, et ainsi de splitter les responsabilit\\xE9s des \\xE9quipes de d\\xE9veloppement. Le backend applicatif se transforme en un Back For Front (BFF) qui est l\\u2019API de communication d\\xE9di\\xE9e au frontend. L\\u2019API gateway peut parfois se substituer \\xE0 ce BFF ou dans certains cas s\\u2019ajouter \\xE0 celui-ci.\")), mdx(\"h2\", null, \"On a juste r\\xE9gl\\xE9 le probl\\xE8me du back\"), mdx(\"p\", null, \"Quand on voit la d\\xE9coupe qui s\\u2019est faite avec le temps, on peut facilement se dire que probl\\xE8me du monolithe a \\xE9t\\xE9 r\\xE9gl\\xE9 en partie. On a \\xE0 pr\\xE9sent une bonne d\\xE9coupe du back avec une s\\xE9paration des domaines par API, mais on a toujours une grosse app front qui fait tout (login, gestion du client, de ses contrats, \\u2026). Celle-ci grossit \\xE9galement avec chaque nouvelle feature, nouveau domaine ajout\\xE9, \\u2026\\nAvec cela, viennent les probl\\xE8mes techniques :\\nune application de plus en plus grande \\xE0 d\\xE9ployer (hausse du risque)\\nde plus en plus de code \\xE0 maintenir (et donc difficult\\xE9 de migrations \\xE9volutives vers des nouvelles technologies)\\ndifficult\\xE9 de recruter des personnes comp\\xE9tentes sur une stack qui vieillit\"), mdx(\"h2\", null, \"Du monolithe aux microfrontends\"), mdx(\"p\", null, \"Tout comme pour le back, il fallait donc trouver une solution pour \\xE9viter le fourre-tout. Il nous fallait un moyen de d\\xE9couper une application frontend en domaines ind\\xE9pendants et r\\xE9utilisables et les int\\xE9grer dans les diff\\xE9rentes applications.\\nPour permettre cela, les d\\xE9veloppeurs se sont orient\\xE9s vers la componentization. Chaque composant a ainsi une responsabilit\\xE9 qui lui est propre, et qui pourrait \\xEAtre utilis\\xE9 dans diff\\xE9rents contextes. Elle ne n\\xE9cessiterait qu\\u2019un seul d\\xE9veloppement qui devrait repr\\xE9senter le domaine cibl\\xE9 (et donc indirectement l\\u2019API cibl\\xE9e). Chaque client int\\xE9ress\\xE9 pourrait ensuite reprendre ces fragments et les int\\xE9grer dans son application selon les besoins de ses utilisateurs finaux.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#tl-dr","title":"TL; DR;"},{"url":"#du-monolithe-aux-microservices","title":"Du monolithe aux microservices"},{"url":"#on-a-juste-réglé-le-problème-du-back","title":"On a juste réglé le problème du back"},{"url":"#du-monolithe-aux-microfrontends","title":"Du monolithe aux microfrontends"}]},"parent":{"__typename":"File","relativePath":"introduction.md"},"frontmatter":{"metaTitle":"Qu'est-ce que l'architecture micro frontend","metaDescription":"Qu'est-ce que l'architecture micro frontend"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/","title":"Landing Page"}}},{"node":{"fields":{"slug":"/codeblock/1-index","title":"Sub Page"}}},{"node":{"fields":{"slug":"/codeblock","title":"Syntax Highlighting"}}},{"node":{"fields":{"slug":"/introduction","title":"Qu'est-ce que l'architecture micro frontend ?"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"513b0c49-fc45-5e2a-8399-e2179a3e7b5f"}}}